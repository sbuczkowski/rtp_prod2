#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c)
#+TITLE:      airs_find_uniform
#+AUTHOR:     Steven Buczkowski
#+EMAIL:      sbuczkowski at umbc dot edu
#+LANGUAGE:   en
#+PRIORITIES: A C B
#+CATEGORY:   worg

#+PROPERTY: header-args:matlab :session matlab
#+PROPERTY: header-args :tangle ~/git/rtp_prod2/airs/util/airs_find_uniform.m

* NOTES                                                            :noexport:

* Function Header
** REVISITME removing idtest as a parameter. build it within the code
#+BEGIN_SRC matlab
  function [dbtun, mbt] = airs_find_uniform(head, prof);
  % AIRS_FIND_UNIFORM FOV spatial uniformity check
  % *** build 3x3 FOR/FOV like structure by grouping AIRs scanlines
  % *** in groups of 3 atracks
  %
  % Determine spatial uniformity of AIRS data.  For each ifov it
  % determines the max difference in mean BT (over channels in idtest)
  % of the eight adjacent ifovs.
  %
  % Input:
  %    head    - [structure] RTP header with required fields: (ichan, vchan)
  %    prof    - [structure] RTP profiles with required fields: (robs1,
  %                 rtime, ifov, atrack, xtrack, findex)
  %
  % Output:
  %    dbtun   - [1 x nobs] max delta BT {K}; -9999 if no data
  %    mbt     - [1 x nobs] mean BTobs {K} used in dbtun tests

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  sFuncName = 'airs_find_uniform';
#+END_SRC

* Uniform test channels
#+BEGIN_SRC matlab
  % Test channels (wn) (chosen as closest to corresponding channels in cris uniform clear
  %           1       2
  ftest = [819.312;961.060];
  ntest = length(ftest);
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % Find indices of idtest in head.ichan
  [indtest, deltas] = matchWN2Ind(ftest, head.vchan);
#+END_SRC

  
* Input verification and validation
  Function requires three inputs: head and prof rtp
  structures. Missing either input is a fatal error.

  The CrIS uniform clear code is a mish-mash of statements assigning
  and de-assigning test channels with some appearance that one can
  also call the routines with an arbitrary array of test channels but,
  in the end, it appears the code is actually significantly less
  flexible than it appears. There is also does not appear to be any
  particular reason to make it be flexible. In that light, this AIRS
  version will fix its test channel array as outlined above. Any
  changes to test channels need to be reflected in this routine. If a
  more flexible and general routine is actually needed, this routine
  will need to be re-fit.

#+BEGIN_SRC matlab
  % Check input %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  if (nargin ~= 2)
     error(sprintf('>>> %s: unexpected number of input arguments',sFuncName))
  end

#+END_SRC

  In addition to being called with head and prof structs, both structs
  have fields that are required. Presence of these fields is checked
  here. Missing fields is a fatal error.

#+BEGIN_SRC matlab
  % Required fields %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  hreq = {'ichan', 'vchan'}; 
  preq = {'robs1', 'rtime', 'findex', 'atrack', 'xtrack'}; 
  % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  for ii=1:length(hreq) 
      if (~isfield(head,hreq{ii})) 
	 error(sprintf('>>> %s: head is missing required field %s', sFuncName, hreq{ii})) 
      end 
  end 

  for ii=1:length(preq) 
      if (~isfield(prof,preq{ii})) 
	 error(sprintf('>>> %s: prof is missing required field %s', sFuncName, preq{ii}))
      end 
  end 
#+END_SRC


* Background
  
  This routine was built from an existing routine for CrIS which was
  complicated by 3x3 FOV array per FOR within each scanline. This
  necessitated some gymnastics in addressing individual ranges of FOVs
  and sub-scanlines. The situation is simpler in AIRS data due to the
  single FOV scanline.

#+BEGIN_SRC matlab 

  % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % AIRS observations come as a scanline of single FOVs which can addressed directly
  % by values of prof.xtrack and prof.atrack. Gymnastics similar to CrIS will still be 
  % required to match up FOVs for the actual uniformity tests
  %    001 002 003  004 005 006       088 089 090
  %    001 002 003  004 005 006  ...  088 089 090
  %    001 002 003  004 005 006       088 089 090
  % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#+END_SRC

* Uniform test channels

The actual uniformity test looks at the delta in BT between a FOV and
the other FOVs making up the 3x3 matrix surrounding the test
FOV. Since we've verified all inputs and test channels, calculate BTs
for all obs in only the test channels. For each observation, store the
mean of the test channel BTs.

#+BEGIN_SRC matlab

  % Compute BT of test channels
  r = prof.robs1(indtest,:);
  ibad = find(r < 1E-6);
  r(ibad)=1E-6;
  mbt = mean(real(rad2bt(ftest,r))); % [1 x nobs]
  clear r

#+END_SRC

* Find unique scanlines

Uniformity testing requires defining the matrix of observations/FOVS
surrounding a given FOV. In AIRS data, this is accomplished simply by
finding the scanline containing the FOV in question as well as the
previous and following scanlines. This constrains input data to be a
series of obs contiguous in time. This precludes any arbitrary
collection of observations and makes most sense to be done from
complete granules. 

The CrIS code upon which this is based mocks up prof.findex as all
ones since CrIS data does not contain findex values. This effectively
limits that code to working only with a single granule to avoid
collisions in the unique scanline code below. AIRS data is complete
with findex so the following code should work any combination of
complete, contiguous granules.

#+BEGIN_SRC matlab

  % Determine unique scanlines (as findex*200 + atrack) and their mean
  % rtime 
  % *NOTE: the multiplier 200 needs to be as large, or larger,
  % than the range of atrack values for the instrument. For AIRS, this range
  % is 1:135. Original CrIS version which served as the base for this uses 100
  % where CrIS granules have 4,60,90 atrack values typically. CrIS rtp data 
  % does not carry findex values so this really only works reliably for a single
  % granule while for AIRS, this code should be reliably general.

  f100a = round(200*prof.findex + prof.atrack); % exact integer
  uf100a = unique(f100a);
  nscan = length(uf100a);
  nobs = length(prof.findex);

#+END_SRC


* Uniformity test

 Loop over available scanlines. Since we ultimately need 3x3 matrices
 of obs for the uniformity test and AIRS scanlines are a single line
 of obs, we start on scanline two. Scanline one obs uniformity data
 cannot exist. Similarly, we use the final scanline but it does not
 contribute uniformity values and those obs are, essentially, lost
 from uniform clear consideration. In typical rtp processing, this
 means we lose 180 obs per granule in AIRS from the first and last scanline.

 A similar issue causes loss of the first and last FOVs on each
 scanline so, in total, the loss is 2*(nscan-2) + 180 obs. Run by
 granule, this drops 446 obs (~3.7%) from uniform clear consideration
 right off the top. By comparison, we can only keep about 60000 clear
 obs in the final daily rtps which is only about 2% of the total daily
 obs. Losing an additional 3-4% on top should not present a hazard to
 data collection. 

 The CrIS code on which this is based performs a check of average
 rtime for each scanline and looks for neighboring scanlines by time
 delta. AIRS data is grouped by single FOV rows associated with an
 along-track index (atrack). Assuming a granule has obs in time and
 atrack order, we can accomplish the same by simply looking for the
 previous and next atracks. If we restrict this function to only take
 a single granule (i.e. a single findex value), this could be a simple
 increment and decrement of atrack values but, since we built a
 combined key of findex /and/ atrack above, we look for the previous
 and next index in the index of unique scanlines (uf100a).

#+BEGIN_SRC matlab
  % Compute dbtun
  dbtun = -9999*ones(1,nobs);

  ix = 2:89;
  ixm1 = ix - 1;
  ixp1 = ix + 1;
  % REVISITME: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % above, we define 2 test channels and then average the radiances 
  % in those channel in the array mbt which is used later for the actual
  % uniformity test. At the point of that test, the dbt array defined here
  % becomes an 8x88 array of BT diffs between scanline interior FOVs and 
  % all neighbors. The following array definition never has relevance. Is
  % this the way it should be done or do we need to do tests by channel and 
  % average afterwards?
  dbt = zeros(ntest,length(ix));

  FOVsPerScan = 90;  % 90 FOVs/AIRS scanline  (CrIS has 270)

  % Loop over available scanlines. Since we ultimately need 3x3 matrices
  % of obs for the uniformity test and AIRS scanlines are a single line
  % of obs, we start on scanline two. Similarly, we lose the last line.

  for ii=2:nscan-1

     indscan = find(f100a == uf100a(ii));
     if (length(indscan) ~= FOVsPerScan)
	error(sprintf('>>> %s: unexpected length for indscan', sFuncName))
     end

     iprev = ii-1;
     inext = ii+1;

     % Grab previous row
     indprev = find(f100a == uf100a(iprev));
     if (length(indprev) ~= FOVsPerScan)
	error(sprintf('>>> %s: unexpected length for indprev', sFuncName))
     end
     % Grab next row
     indnext = find(f100a == uf100a(inext));
     if (length(indnext) ~= FOVsPerScan)
	error(sprintf('>>> %s: unexpected length for indnext', sFuncName))
     end

     btp = mbt(indprev);
     btc = mbt(indscan);
     btn = mbt(indnext);
     % build BT diffs between scanline interior FOVs and all neighbors
     dbt(1,:) = abs(btc(ix) - btp(ixm1));
     dbt(2,:) = abs(btc(ix) - btp(ix));
     dbt(3,:) = abs(btc(ix) - btp(ixp1));
     dbt(4,:) = abs(btc(ix) - btc(ixm1));
     dbt(5,:) = abs(btc(ix) - btc(ixp1));
     dbt(6,:) = abs(btc(ix) - btn(ixm1));
     dbt(7,:) = abs(btc(ix) - btn(ix));
     dbt(8,:) = abs(btc(ix) - btn(ixp1));
     inddbt = indscan(ix);
     dbtun(inddbt) = max(dbt);
  end

  %%% end of routine %%%
#+END_SRC
