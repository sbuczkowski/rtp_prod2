#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c)
#+TITLE:      airs_uniform_clear
#+AUTHOR:     Steven Buczkowski
#+EMAIL:      sbuczkowski at umbc dot edu
#+LANGUAGE:   en
#+PRIORITIES: A C B
#+CATEGORY:   worg

#+PROPERTY: header-args:matlab :session matlab
#+PROPERTY: header-args :tangle ~/git/rtp_prod2/airs/util/airs_uniform_clear.m

* Function Header
#+BEGIN_SRC matlab
  function [pout, ikeep] = airs_uniform_clear(head, hattr, prof, pattr)
  % AIRS_UNIFORM_CLEAR select clear obs
  % 
  % Run the AIRS airs_uniform.m and airs_find_clear.m codes for a set of
  % input observations. The input RTP must contain sarta clear calcs as
  % p.rclr. Lack of a required field results in failure and exit from the
  % routine
  %
  % test channel arrays are built in airs_find_clear and airs_uniform
  %
  % Input:
  %   head, hattr, prof, pattr  - std RTP structures
  %
  % Output:
  %    pout -   prof, but with added field prof.iudef having the settings of 0,1,2,4,8
  %         = where 1,2,4,8 are uniform clear, site, dcc, random (0 otherwise)
  %
  % Created: April 2018, Steven Buczkowski - based on CrIS code from Scott Hannon and Sergio Machado
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  sFuncName = 'airs_uniform_clear';
#+END_SRC

* Addpaths
#+BEGIN_SRC matlab
addpath /asl/matlib/aslutil        % mktemp
addpath /asl/matlib/h4tools        % rtpread, rtpwrite
addpath /asl/matlib/rtptools       % subset_rtp
#+END_SRC

* Input validation and initialization
#+BEGIN_SRC matlab
  % Required fields %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  hreq = {'ichan', 'vchan'}; 
  preq = {'rclr'};
  % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  for ii=1:length(hreq) 
      if (~isfield(head,hreq{ii})) 
	 error(sprintf('>>> %s: head is missing required field %s', sFuncName, hreq{ii})) 
      end 
  end 

  % REVISITME: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % needed until renaming rcalc -> rclr is completed
  % (safe to leave in after but, will be unnecessary)
  % Mostly this is just needed to allow testing with existing allfov rtp data
  % and, in normal use of straight granule reads, this would be handled by the 
  % calling function after running sarta.
  if (isfield(prof, 'sarta_rclearcalc') & isfield(prof, 'rcalc'))
      prof.rclr = prof.sarta_rclearcalc;
      prof.rcld = prof.rcalc;
      prof = rmfield(prof, 'sarta_rclearcalc');
      prof = rmfield(prof, 'rcalc');
  elseif (isfield(prof, 'rcalc') & ~isfield(prof, 'sarta_rclearcalc'))
      prof.rclr = prof.rcalc;
      prof = rmfield(prof, 'rcalc');
  end
  % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  for ii=1:length(preq) 
      if (~isfield(prof,preq{ii})) 
	 error(sprintf('>>> %s: prof is missing required field %s', sFuncName, preq{ii}))
      end 
  end 

#+END_SRC

* Uniform check

idLOres_testu = [272; 499];
%   idtestu = [276; 503; 762];  cris hires
%   idtestu = [272; 499; 732];  cris lowres
% cris code builds this array and then deletes last entry to get rid
% of 1232 line ???
xufreq = [819.375; 961.25; 1232.5];
xcfreq = [819.375;856.875;912.5;961.25;1043.75;1071.25;1083.125;1093.125;1232.5];

#+BEGIN_SRC matlab
% Run xuniform
disp('running airs_find_uniform')
[dbtun, mbt] = airs_find_uniform(head, prof);
nobs = length(dbtun);
ibad1 = find(mbt < 150);
#+END_SRC

* Clear check
#+BEGIN_SRC matlab
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Run xfind_clear
disp('running airs_find_clear')
[iflagsc, bto1232, btc1232] = airs_find_clear(head, prof, 1:nobs);
#+END_SRC

* decide Keep/no-keep
#+BEGIN_SRC matlab
iclear_sea    = find(iflagsc == 1 & abs(dbtun) < 0.5 & prof.landfrac <= 0.01);
iclear_notsea = find(iflagsc == 1 & abs(dbtun) < 1.0 & prof.landfrac >  0.01);
iclear = union(iclear_sea, iclear_notsea);

% Determine all indices to keep
iclrflag = zeros(1,nobs);
iclrflag(iclear) = 1;
ireason = iclrflag;
#+END_SRC

* subset, traceability, and output
#+BEGIN_SRC matlab
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Store clear flags and ancllary data in iudef and/or udef arrays within pout

   iclrflag = iclrflag(ikeep);

   % Cut ireason to 4 bits
   icut = find(ireason > 32);
   ireason(icut) = ireason(icut) - 32;
   icut = find(ireason > 16);
   ireason(icut) = ireason(icut) - 16;

   pout.clrflag = iclrflag;  
   if (~isfield(pout,'udef'))
      pout.udef = zeros(20,nkeep);
   end
   pout.udef(13,:) = dbtun(ikeep);
   pout.udef(14,:) = bto1232(ikeep);
   pout.udef(15,:) = btc1232(ikeep);
   if (~isfield(pout,'iudef'))
      pout.iudef = zeros(10,nkeep);
   end
   pout.iudef(1,:) = ireason;
   pout.iudef(2,:) = isite;

   junk = set_attr(pattr, 'udef(13,:)', 'spatial uniformity test dBT {dbtun}');
   pattr = set_attr(junk, 'udef(14,:)', 'BTobs 1232 wn {bto1232}');
   junk = set_attr(pattr, 'udef(15,:)', 'BTcal 1232 wn {btc1232}');
   pattr = set_attr(junk, 'iudef(1,:)', ...
      'selection reason: 1=clear, 2=site, 4=DCC, 8=random {reason}');
   junk = set_attr(pattr, 'iudef(2,:)', 'fixed site number {sitenum}');
   pattr = junk;


%%% end of program %%%
#+END_SRC
